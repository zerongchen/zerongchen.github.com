{"meta":{"title":"Roy's Note","subtitle":null,"description":null,"author":"陈泽荣","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"SOLID","slug":"SOLID","date":"2021-04-26T14:39:36.000Z","updated":"2021-04-26T15:55:49.449Z","comments":true,"path":"2021/04/26/SOLID/","link":"","permalink":"http://yoursite.com/2021/04/26/SOLID/","excerpt":"","text":"优秀视频来源https://www.youtube.com/watch?v=rtmFCcjEgEwS: single responsiblity principle极可能简单的职责，单类单职责O: open extension colose modify 对扩展开放，对修改闭合12345678910public void pay(PayRequest request)&#123; String type = request.type; if(\"credit\".equals(type))&#123; new CreditPay().pay(); &#125;else&#123; new crashPay().pay(); &#125;&#125;上述随着pay的方式越来越多，if会出现越来越多分分支，如果这个代码出现在service乃至controller，就回不得不改到这个类，这时候适合用工厂模式12345678910111213141516171819202122232425262728public void pay(PayRequest request)&#123; String type = request.type; PayFactory.initPay(type).pay()&#125;public class PayFactory&#123; public Pay initPay(String type)&#123; if(\"credit\".equals(type))&#123; new CreditPay(); &#125;else&#123; new crashPay(); &#125; &#125; public interface Pay&#123; pay(); &#125; public CreditPay implements Pay&#123; //dosomething &#125; public CrashPay implements Pay&#123; //dosomething &#125;&#125;L: Liskov Subscription principle 里氏替换原则派生类必须能够替代父类，消费者无需知道任何父类接口的实现类，必须可以替换集成改父类的其他实现类任何子类接口实现的预期必须一致I: interface segregation principle 接口隔离原则client端不应该依赖没用的方法依赖的接口改变不应该影响client 端采用单一的，专职的接口替换臃肿的接口1234567891011121314151617181920Subscriber implements Model&#123; public void subscribe()&#123; &#125; public void subscribe()&#123; &#125; public Mail getNotifyEmail()&#123; &#125; &#125;public Notification&#123; public send(Subscriber s,String message)&#123; s.getNotifyEmail().q(message); &#125;&#125;上述Notification.send 的入参是Subscriber，但是只用到其中一个实现。subscriber 的接口改变，比如增加，或者删除subscribe方法，都会或多或少影响到 Notification对于Notification来说Subscriber比较臃肿解决方法：定义单独一个接口作为Send的第一个参数，且该接口只有一个实现方法 getNotifyEmailD: Dependency invesion principle 依赖独立上层调下层采用抽象的形式，而不是具体的实现类。比如创建用户的实现。12345678public List&lt;String&gt; getUser()&#123;&#125;public void createUser(UserModel usermodel)&#123;&#125;针对这类实现，最好采用抽像的方式，区分不同DB之间的操作","categories":[],"tags":[]},{"title":"Memory-EfficientJavaCode","slug":"Memory-Efficient-Java-Code","date":"2021-04-13T16:15:46.000Z","updated":"2021-07-14T09:10:17.272Z","comments":true,"path":"2021/04/14/Memory-Efficient-Java-Code/","link":"","permalink":"http://yoursite.com/2021/04/14/Memory-Efficient-Java-Code/","excerpt":"","text":"初识 java对象内存int t=4; 在java中需要多少个位表示int？ 4个byte ，32bit但是Integer对象呢，需要多少位呢？1Integer t = new Integer(4);答案是128位，也就是int的4倍（32位系统）4 8 12 16|- - - - |- - - - |- - - - |- - - - ||class point | flags | lock info | value = 4 |64bit 系统需要 28字节 共 2248 16 24 28|- - - - |- - - - |- - - - |- - - - ||class point | flags | lock info | value = 3 |","categories":[],"tags":[]},{"title":"spring-tomcat-apr","slug":"spring-tomcat-apr","date":"2021-03-08T09:39:21.000Z","updated":"2021-07-14T09:09:46.345Z","comments":true,"path":"2021/03/08/spring-tomcat-apr/","link":"","permalink":"http://yoursite.com/2021/03/08/spring-tomcat-apr/","excerpt":"","text":"spring-tomcat-apr要求实现安装 JDK 1.8 ; gcc 版本 &gt;4.5，该安装暂时忽略ssl协议以下安装包目前存在OSS oss://kanban-bj/tool/apr/1,apr-1.7.0进入该目录 执行 ./configure –prefix=${apr_path} &amp; make &amp; make install123wget http://mirrors.hust.edu.cn/apache//apr/apr-1.7.0.tar.gztar xvf apr-1.7.0.tar.gz ./configure --prefix=$&#123;apr_path&#125; &amp; make &amp; make install其中路径 ${apr_path} 是APR安装目录，JNI执行文件模目录所在地，默认 /usr/local/apr2,apr-util-1.6.1进入该目录 执行 ./configure –with-apr=${apr_path} &amp; make &amp; mak install123wget https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.6.1.tar.gztar xvf apr-util-1.6.1.tar.gz./configure --prefix=$&#123;apr_path&#125; &amp; make &amp; make install如果执行过程中报 xml/apr_xml.c expat.h 找不到的情况能上网的情况下执行 yum install expat-devel 后执行 ./configure –with-apr=${apr_path} &amp; make &amp; mak install不能上网的情况下解压包 expac-2.2.10.tar.bz2123456789101112131415 wget https://github.com/libexpat/libexpat/releases/download/R_2_2_10/expat-2.2.10.tar.bz2 tar xvf expact-2.2.10.tar.bz2 -C ./expat-dir cd ./expat-dir ./cofigure --prefix=$&#123;expat_path&#125; &amp; make &amp; make install # $&#123;expact_path&#125; expat 的安装路径 ./configure --with-apr=$&#123;apr-pat&#125; --with-expat=&#123;expat_path&#125; &amp; make &amp; make install ``` ### 3,apr-iconv-1.2.2 ```shell wget https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gztar xvf apr-iconv-1.2.2.tar.gz./configure --with-apr=&#123;apr_path&#125; &amp; make &amp; make install4,tomcat-native根据自身tomcat 于 http://tomcat.apache.org/native-doc/ 下载1234 cd native./configure --with-apr=&#123;apr_path&#125; --with-java-home=$&#123;JAVA_HOME&#125; --without-ssl &amp; make &amp; make install # 因为没有装openssl 所以这里直接加上 without-ssl 即可5,服务启动加上参数修改配置项 spring.tomcat.protocol=org.apache.coyote.http11.Http11AprProtocol(如果是appolo启动可从appolo 全局变量修改)-Djava.library.path=/usr/local/apr/lib12nohup java -Xmx5G -Xms5G -Djava.library.path=/usr/local/apr/lib -jar view.jar --spring.config.location=shared.properties,view.properties &gt; /dev/null 2&gt;&amp;1 &amp;启动成功的话会打印如下log12345cn.****.valuekanban.TomcatConfig : protocol:org.apache.coyote.http11.Http11AprProtocol@421bba992021-03-08 17:16:12.685+0800 INFO [service-view,,,] 12998 --- [apr-8882-exec-2] c.a.valuekanban.view.core.ViewDelegate : 过滤视图[0ac34610c3d343f288e022087e20b13e-部门事务按来源状态分布]2021-03-08 17:16:12.685+0800 INFO [service-view,,,] 12998 --- [apr-8882-exec-1] c.a.valuekanban.view.core.ViewDelegate : 过滤视图[92a7ad88155443f184a563dccb91790e-事务(重点项目)状态分布]2021-03-08 17:16:12.724+0800 INFO [service-view,,,] 12998 --- [apr-8882-exec-1] c.a.v.view.core.support.StatService : batchVu size: 46,mark目前已经已经生成了一份 8C/16G 的执行文件，oss://kanban-bj/tool/apr/8c/tomcat-apr-bin.tar.gz12ossutil cp oss://kanban-bj/tool/apr/8c/tomcat-apr-bin.tar.gz ./tar xvf tomcat-apr-bin.tar.gz -C /usr/local/目前解压目标文件是在 /usr/local ，其他目前文件测试好像是不生效，另外这些执行文件是基于8C的linux操作系统下生成，\b如果遇到机器是非8C最好重新安装（内存是64位的就不影响）–暂时无测试8c环境生产的文件在4c下是否可以执行，欢迎指正执行上述命令之后进行 步骤 5","categories":[],"tags":[]},{"title":"java_NetWorking-Protocol-Design","slug":"java-NetWorking-Protocol-Design","date":"2020-06-17T09:59:34.000Z","updated":"2021-03-08T09:53:56.442Z","comments":true,"path":"2020/06/17/java-NetWorking-Protocol-Design/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-Protocol-Design/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-interAddress","slug":"java-NetWorking-interAddress","date":"2020-06-17T09:59:19.000Z","updated":"2021-03-08T09:53:56.443Z","comments":true,"path":"2020/06/17/java-NetWorking-interAddress/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-interAddress/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-JarUrlConnection","slug":"java-NetWorking-JarUrlConnection","date":"2020-06-17T09:59:08.000Z","updated":"2021-03-08T09:53:56.441Z","comments":true,"path":"2020/06/17/java-NetWorking-JarUrlConnection/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-JarUrlConnection/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-URL+URLConnection","slug":"java-NetWorking-URL-URLConnection","date":"2020-06-17T09:58:50.000Z","updated":"2021-03-08T09:53:56.443Z","comments":true,"path":"2020/06/17/java-NetWorking-URL-URLConnection/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-URL-URLConnection/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-UDP-DatagramSocket","slug":"java-NetWorking-UDP-DatagramSocket","date":"2020-06-17T09:58:27.000Z","updated":"2021-03-08T09:53:56.442Z","comments":true,"path":"2020/06/17/java-NetWorking-UDP-DatagramSocket/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-UDP-DatagramSocket/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-serversocket","slug":"java-NetWorking-serversocket","date":"2020-06-17T09:57:54.000Z","updated":"2021-03-08T09:53:56.443Z","comments":true,"path":"2020/06/17/java-NetWorking-serversocket/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-serversocket/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking-socket","slug":"java-NetWorking-socket","date":"2020-06-17T09:57:48.000Z","updated":"2021-03-08T09:53:56.443Z","comments":true,"path":"2020/06/17/java-NetWorking-socket/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking-socket/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java_NetWorking","slug":"java-NetWorking","date":"2020-06-17T09:57:39.000Z","updated":"2021-03-08T09:53:56.444Z","comments":true,"path":"2020/06/17/java-NetWorking/","link":"","permalink":"http://yoursite.com/2020/06/17/java-NetWorking/","excerpt":"","text":"http://tutorials.jenkov.com/java-networking/index.html","categories":[],"tags":[{"name":"java网络","slug":"java网络","permalink":"http://yoursite.com/tags/java网络/"}]},{"title":"话谈JSR_292","slug":"话谈JSR-292","date":"2019-12-01T01:54:11.000Z","updated":"2021-03-08T09:53:56.449Z","comments":true,"path":"2019/12/01/话谈JSR-292/","link":"","permalink":"http://yoursite.com/2019/12/01/话谈JSR-292/","excerpt":"","text":"JSR-292 是JVM架构的一重大调整；在java中，方法调用涉及到哪些1，Naming 采用名字符号索引目标地址2，Linking 使用目标地址3，Selecting 方法选择4，Adapting 遵循方法调用时双方约定","categories":[],"tags":[]},{"title":"jib","slug":"jib","date":"2019-07-17T14:53:42.000Z","updated":"2021-03-08T09:53:56.444Z","comments":true,"path":"2019/07/17/jib/","link":"","permalink":"http://yoursite.com/2019/07/17/jib/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"深入jvm10-收集器.md","slug":"深入jvm10-收集器","date":"2019-07-15T14:28:29.000Z","updated":"2021-03-08T09:53:56.448Z","comments":true,"path":"2019/07/15/深入jvm10-收集器/","link":"","permalink":"http://yoursite.com/2019/07/15/深入jvm10-收集器/","excerpt":"","text":"新生代的收集器Seria单线程收集器，工作是必须 stop the word可控制参数： -XX:SurvivorRatio , -XX:PretenureSizeThreadHold -XX:HandlePromotionFailure算法：采用复制算法ParNew多线程收集器，工作是必须 stop the word可控制参数： -XX:SurvivorRatio , -XX:PretenureSizeThreadHold -XX:HandlePromotionFailure -XX:+UseParNewGC算法：采用复制算法默认与CMS结合作为新生代收集器Parallel Scavenge重点关注吞吐量 throughput = 运行代码时间/(运行代码时间+垃圾收集时间)参数控制：-XX:+MaxGCPauseMillis 最大垃圾收集停顿时间-XX:GCTimeRatio:直接设置吞吐量 （垃圾收集时间占总时间的比率）因为其没有使用传统的GC收集器，暂时无法与CMS一起配合使用老年代的收集器Seria Old1：与Parallel Scavenge配合使用2：CMS的后备方案（Concurrent Model failure的时候）Parllel OldParallel Scavenge 的老年代版本算法：标记-整理CMS算法：标记-清除步骤：1 ，初始标记 （标记GC-root能关联到的对象）2 ，并发标记3 ，重新标记4 ，并发清除G1","categories":[],"tags":[]},{"title":"深入java9","slug":"深入java9","date":"2019-07-08T15:33:47.000Z","updated":"2021-03-08T09:53:56.447Z","comments":true,"path":"2019/07/08/深入java9/","link":"","permalink":"http://yoursite.com/2019/07/08/深入java9/","excerpt":"","text":"@Target({ ElementType.TYPE, ElementType.FIELD })@Target用来限定目标注解所能标注的 Java 结构 (比如上面的类和字段；该注解可以作用在类和字段上)注解共有三种不同的生命周期：SOURCE，CLASS或RUNTIME，分别表示注解只出现在源代码中，只出现在源代码和字节码中，以及出现在源代码、字节码和运行过程中。","categories":[],"tags":[]},{"title":"docker的网络设置","slug":"docker的网络设置","date":"2019-07-01T15:09:15.000Z","updated":"2021-03-08T09:53:56.441Z","comments":true,"path":"2019/07/01/docker的网络设置/","link":"","permalink":"http://yoursite.com/2019/07/01/docker的网络设置/","excerpt":"","text":"容器间是如何互相通讯的1，iptables 是否开启。在容器起来的时候会自动开启Iptables（可以手动开启iptables）2，需要互相访问的容器是否已经是链接到相同的网桥上面去（即 拓扑图是不是互通的）容器起来的时候会创建一对veth ，一个放在网桥（docker0） 对内的接口上，命名一般都是vethXXXX，另外一个veth会放在容器内部命名问veth0(可以联想成，我们自己的电脑的那个veth0，是默认的网卡)【veth 在docker0 的对内接口可以通过brctl show 查看docker0 上 interfaces】当一个数据包到达veth 一端的时候，另外一段也可以收到一样的数据（这是通过内核数据拷贝实现的，所以两端传输的数据速度很快，容器间的相互访问，基本上就是内核的数据拷贝。几乎可以忽略性能影响12bridge name bridge id STP enabled interfacesdocker0 8000.0242f9c70e0f no veth0622f452，容器与外界是如何互相通讯的docker0 网桥是在docker启动的时候初始话的一个网桥（可以自定义）。然后自动分配一个ip地址（大多例如：172.17.42.1/16）;一对veth的创建后","categories":[],"tags":[]},{"title":"深入jvm8","slug":"深入jvm8","date":"2019-06-29T12:13:39.000Z","updated":"2021-03-08T09:53:56.449Z","comments":true,"path":"2019/06/29/深入jvm8/","link":"","permalink":"http://yoursite.com/2019/06/29/深入jvm8/","excerpt":"","text":"方法内联是指，在编译过程中，当遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。即时编译器既可以在解析过程中替换方法调用字节码，也可以在 IR 图中替换方法调用 IR 节点。这两者都需要将目标方法的参数以及返回值映射到当前方法来。方法内联有许多规则。除了一些强制内联以及强制不内联的规则外，即时编译器会根据方法调用的层数、方法调用指令所在的程序路径的热度、目标方法的调用次数及大小，以及当前 IR 图的大小来决定方法调用能否被内联。今天的实践环节，你可以利用虚拟机参数 -XX:+PrintInlining 来打印编译过程中的内联情况。具体每项内联信息所代表的意思","categories":[],"tags":[]},{"title":"深入jvm7","slug":"深入jvm7","date":"2019-06-20T15:46:39.000Z","updated":"2021-03-08T09:53:56.448Z","comments":true,"path":"2019/06/20/深入jvm7/","link":"","permalink":"http://yoursite.com/2019/06/20/深入jvm7/","excerpt":"","text":"即时编译-直接将Java字节码编译成机器码，运行在底层硬件之上，这么玩是为了提高代码的执行效率，通俗点就是能使代码跑的更快一些即时编译的触发点是热点代码，即 即时编译仅针对热点代码来触发，热点代码是通过方法的调用次数或者回边循环的次数来标示的，这里也侧面反映出来即时编译是针对方法块的java虚拟机包含多个编译器 C1 C2 Graal其中Graal是试验性的编译器jdk7 之前 C1 和 C2 分别用 -client -server来制定C1 C2 的编译器JDK7 之后引入分层编译的概念0 ： 解释执行1 ： 执行无 profiling 的C1代码2 ： 执行仅带方法调用次数以及循环回边执行次数profiling的代码3 ： 执行所有带profiling的C1代码4 ： 执行所有C2代码在 5 个层次的执行状态中，1 层和 4 层为终止状态java 8 之后是默认开启分层编译的通常情况下，方法会首先被解释执行，然后被 3 层的 C1 编译，最后被 4 层的 C2 编译。即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。##2今天我介绍了 Java 虚拟机的 profiling 以及基于所收集的数据的优化和去优化。通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。当方法被 3 层 C1 所编译时，生成的 C1 代码将收集条件跳转指令的分支 profile，以及类型相关指令的类型 profile。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profile。基于分支 profile 的优化以及基于类型 profile 的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile","categories":[],"tags":[]},{"title":"深入jvm","slug":"深入jvm6","date":"2019-06-20T14:51:11.000Z","updated":"2019-06-20T14:51:42.000Z","comments":true,"path":"2019/06/20/深入jvm6/","link":"","permalink":"http://yoursite.com/2019/06/20/深入jvm6/","excerpt":"","text":"1:Java语法糖-是一种帮助开发人员提高开发效率的小甜点，原理是将一些繁琐的事情交给编译器来处理，开发人员少做一些事情，当然，本纸上这些事情还必须要做，只是有编译器来做了2:Java语法糖有那几种呢？如下所示：2-1:包装类型和基本类型间的转换，自动装箱和拆箱的设计2-2:泛型的设计2-3:变长参数的设计2-4:try-with-resources，关闭资源的设计2-5:在同一个catch代码块中捕获多种异常2-6:finally代码块总是被执行的设计2-7:foreach循环数组的设计2-8:foreach循环Iterable对象的设计3:编译器的具体实现细节不是很清楚，猜测是识别出对应的语法然后填充上对应的代码，将语法糖还原成其本质-一些重复繁琐的代码块4:之前有同事问我泛型是怎么实现的？我讲不出来，只晓得使用泛型后，不需要写类型强转的代码了，如果类型不对也会有提示且编译失败，现在知道的多一点了，本质上类型强转的工作还是必须要做的，只是不是有开发人员来做了，由编译器来做，并且编译器会擦除掉对应的泛型信息，使用合适的父类型来代替，可能是Object类也可能是声明泛型时指定的继承的类","categories":[],"tags":[]},{"title":"深入jvm5.md","slug":"深入jvm5","date":"2019-06-18T15:32:16.000Z","updated":"2021-03-08T09:46:09.348Z","comments":true,"path":"2019/06/18/深入jvm5/","link":"","permalink":"http://yoursite.com/2019/06/18/深入jvm5/","excerpt":"","text":"#java 内存模型java内存模型的定义决定了java数据操作的顺序性和准确性，程序上讲，因为操作系统的差异性，导致了程序操作内存的差异性，java内存模型的定义也保证了应用层和物理层面的隔离。###java内存模型目的：是为了保证程序变量访问规则，即在虚拟中中保存变量-&gt;变量从内存中取出来的底层细节等一系列访问规则。【变量】：指程序中的公共变量，实例，静态字段，静态反复，构成数组的对象（不包含局部变量等线程私有变量）。java内存规定：所有变量存在主内存中。与之对应的是各个线程也有相对应的工作内存。每个线程工作的时候，如果访问到主内存的变量，会将该对象的主内存副本拷贝到工作内存中（只拷贝访问字段）。线程对变量的操作都是基于工作内存的，之后再同步到主内存中去。这里的主内存和工作内存和虚拟机的内存分配不是同一个层次的分层，没有可比性。如果非要对应的话可以理解为主内存区是指 堆空间，方法区（代码块和静态变量，常量池）；工作内存指：线程栈帧；java内存的交互：lock，unlock,read,load,use,assign.store,write。所有针对于内存大操作都是成对出现的，没有单独存在的说法比如：lock &amp;&amp; unlock , read &amp;&amp; load &amp;&amp; use, store &amp;&amp; wirte;java内存模型的3个特征：原子性可见性有序性###java内存模型原则happen-before 原则程序次序规则管程锁定volatile程序启动程序终止程序终端程序对象终结传递性volatile型变量volatile 之所有能够起到及时属刷新主内的数据，保证写操作和读操作的顺序正确性，禁止指令重排，主要是volatile 变量的操作回引入 “内存屏障” ， 内存屏障会在java转为字节码的时候插入一条内存屏障语句。当程序执行到内存屏障时默认程序之前的操作都是完成了的，立马内存同步，从而保证了数据的可见性和重拍的限制。remark64位虚拟中操作long Double等64位变量时，保存的都是32高位和低位保存，这样子long，Double就不是原子操作了，就会出现一个意料之外的数值。但是在现有的虚拟账号不会有这个问题，只要原因是引入了 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素，来确保long Double操作时加锁","categories":[],"tags":[]},{"title":"深入jvm4","slug":"深入jvm4","date":"2019-06-07T07:51:56.000Z","updated":"2019-06-07T16:22:16.000Z","comments":true,"path":"2019/06/07/深入jvm4/","link":"","permalink":"http://yoursite.com/2019/06/07/深入jvm4/","excerpt":"","text":"本文的目的是介绍一个工具ASM，从字节码层面分析代码，修改字字节码修改框架，开始ASM之前，先了解下访问者模式访问者模式（Visitor Pattern）意图：主要将数据结构与数据操作分离。主要解决：稳定的数据结构和易变的操作耦合问题。何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。如何解决：在被访问的类里面加一个对外提供接待访问者的接口。关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。show me the code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980interface Element &#123; // 1. accept(Visitor) interface public void accept( Visitor v ); // first dispatch&#125;class This implements Element &#123; // 1. accept(Visitor) implementation public void accept( Visitor v ) &#123; v.visit( this ); &#125; public String thiss() &#123; return &quot;This&quot;; &#125;&#125;class That implements Element &#123; public void accept( Visitor v ) &#123; v.visit( this ); &#125; public String that() &#123; return &quot;That&quot;; &#125;&#125;class TheOther implements Element &#123; public void accept( Visitor v ) &#123; v.visit( this ); &#125; public String theOther() &#123; return &quot;TheOther&quot;; &#125;&#125;// 2. Create a &quot;visitor&quot; base class with a visit() method for every &quot;element&quot; typeinterface Visitor &#123; public void visit( This e ); // second dispatch public void visit( That e ); public void visit( TheOther e );&#125;// 3. Create a &quot;visitor&quot; derived class for each &quot;operation&quot; to perform on &quot;elements&quot;class UpVisitor implements Visitor &#123; public void visit( This e ) &#123; System.out.println( &quot;do Up on &quot; + e.thiss() ); &#125; public void visit( That e ) &#123; System.out.println( &quot;do Up on &quot; + e.that() ); &#125; public void visit( TheOther e ) &#123; System.out.println( &quot;do Up on &quot; + e.theOther() ); &#125;&#125;class DownVisitor implements Visitor &#123; public void visit( This e ) &#123; System.out.println( &quot;do Down on &quot; + e.thiss() ); &#125; public void visit( That e ) &#123; System.out.println( &quot;do Down on &quot; + e.that() ); &#125; public void visit( TheOther e ) &#123; System.out.println( &quot;do Down on &quot; + e.theOther() ); &#125;&#125;class VisitorDemo &#123; public static Element[] list = &#123; new This(), new That(), new TheOther() &#125;; // 4. Client creates &quot;visitor&quot; objects and passes each to accept() calls public static void main( String[] args ) &#123; UpVisitor up = new UpVisitor(); DownVisitor down = new DownVisitor(); for (int i=0; i &lt; list.length; i++) &#123; list[i].accept( up ); &#125; for (int i=0; i &lt; list.length; i++) &#123; list[i].accept( down ); &#125; &#125;&#125;以上最终的结果是123do Up on This do Down on Thisdo Up on That do Down on Thatdo Up on TheOther do Down on TheOtherASM 里面正是使用了访问者的模式被访问者（Acceptors） 有 ClassReader class, the MethodNode class访问者（Visitors interface）有 ClassVisitor, AnnotationVisitor, FieldVisitor, MethodVisitor.","categories":[],"tags":[]},{"title":"深入jvm3","slug":"深入jvm3","date":"2019-06-05T16:48:32.000Z","updated":"2019-06-07T03:30:05.000Z","comments":true,"path":"2019/06/06/深入jvm3/","link":"","permalink":"http://yoursite.com/2019/06/06/深入jvm3/","excerpt":"","text":"java中重写和重载是基于参数类型和返回值类型的：统称方法描述符重载：方法名称一样，描述符不一样；这个情况同样存在父类和子类拥有同样的方法名，但是描述符不一样也是重载；重写也是依赖方法秒速符的：如果父类的方法描述和子类的方法描述符一样，说明子类的方法重写了父类的方法；但是在java语言中和java虚拟机中，方法描述符不一样；这种情况下，虚拟机采用桥接弥补这个不足比如：123456789101112131415public class Node&lt;T&gt;&#123; public T data; public void setData(T data)&#123; this.data=data; System.out.print(&quot;node.setData&quot;); &#125;&#125;public class MyNode extends Node&lt;String&gt;&#123; public String data; public void setData(String data)&#123; this.data=data; System.out.print(&quot;MyNode.setData&quot;); &#125;&#125;如上述例子中MyNode中的setData(String data) 重写了Node中的setData(Object data)这个对于写过java语音的程序员来说并不陌生，但是对于java虚拟机判定重写标准来说，这两个方法的方法描述并不一致。这时候就是java虚拟机中采用了桥接的方式弥补这个javap -v class 文件查看MyNode中的字节码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596Classfile /Users/chenzr/study/22 深入拆解 Java 虚拟机/test/less4/MyNode.class Last modified 2019-6-6; size 590 bytes MD5 checksum 7d939265a6973b1c1b1866ec806f93dd Compiled from &quot;Brige.java&quot;class MyNode extends Node&lt;java.lang.String&gt; minor version: 0 major version: 52 flags: ACC_SUPERConstant pool: #1 = Methodref #9.#23 // Node.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #8.#24 // MyNode.data:Ljava/lang/String; #3 = Fieldref #25.#26 // java/lang/System.out:Ljava/io/PrintStream; #4 = String #27 // MyNode.setData #5 = Methodref #28.#29 // java/io/PrintStream.print:(Ljava/lang/String;)V #6 = Class #30 // java/lang/String #7 = Methodref #8.#31 // MyNode.setData:(Ljava/lang/String;)V #8 = Class #32 // MyNode #9 = Class #33 // Node #10 = Utf8 data #11 = Utf8 Ljava/lang/String; #12 = Utf8 &lt;init&gt; #13 = Utf8 ()V #14 = Utf8 Code #15 = Utf8 LineNumberTable #16 = Utf8 setData #17 = Utf8 (Ljava/lang/String;)V #18 = Utf8 (Ljava/lang/Object;)V #19 = Utf8 Signature #20 = Utf8 LNode&lt;Ljava/lang/String;&gt;; #21 = Utf8 SourceFile #22 = Utf8 Brige.java #23 = NameAndType #12:#13 // &quot;&lt;init&gt;&quot;:()V #24 = NameAndType #10:#11 // data:Ljava/lang/String; #25 = Class #34 // java/lang/System #26 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #27 = Utf8 MyNode.setData #28 = Class #37 // java/io/PrintStream #29 = NameAndType #38:#17 // print:(Ljava/lang/String;)V #30 = Utf8 java/lang/String #31 = NameAndType #16:#17 // setData:(Ljava/lang/String;)V #32 = Utf8 MyNode #33 = Utf8 Node #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 print&#123; public java.lang.String data; descriptor: Ljava/lang/String; flags: ACC_PUBLIC MyNode(); descriptor: ()V flags: Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method Node.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 public void setData(java.lang.String); descriptor: (Ljava/lang/String;)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: putfield #2 // Field data:Ljava/lang/String; 5: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 8: ldc #4 // String MyNode.setData 10: invokevirtual #5 // Method java/io/PrintStream.print:(Ljava/lang/String;)V 13: return LineNumberTable: line 12: 0 line 13: 5 line 14: 13 public void setData(java.lang.Object); descriptor: (Ljava/lang/Object;)V flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: checkcast #6 // class java/lang/String 5: invokevirtual #7 // Method setData:(Ljava/lang/String;)V 8: return LineNumberTable: line 9: 0&#125;Signature: #20 // LNode&lt;Ljava/lang/String;&gt;;SourceFile: &quot;Brige.java&quot;大家可以看到 flag包含 ACC_BRIDGE, ACC_SYNTHETIC 表示了桥接的意思，在这里就是MyNode setData(Object)需要桥接保证重写语义（方法描述否）java 中方法的调用1，对于重载（方法描述符中能够确认的）非私有静态方法，编译后的java指令是invokestatic，即在编译后就已经确认了目标方法（静态绑定）2，java里对于非私有实例化方法，接口调用 编译后的java指令是invokevirtual invokeinterface 等指令，这既是java的虚方法调用。对于虚方法一般都是在java运行中才去动态绑定执行的。对于虚方法的调用，java采用了空间换区时间的方法；（1） 方法表（参考Linux里，上层对内核的调用也是使用了方法表的调用。。。待补充）。每个类会生成一个方法表，子类方法表拥有父类的所有方法，而且其子类在方法表上的索引值和重写父类方法的索引一样（2）内联缓存：一种加快动态版绑定的缓存。其中涉及单态，多态，超多态的感念。java运行阶段，大部分的虚方法调用都是一个情况下回使用单态，实现快速动态绑定；如果是多态和超多态的情况下（多个实现类。。。）会去轮训多态内联缓存，将调用的方法拿出来。实际多态的内联缓存和方法表的调用已经没有多大区别了，甚至会因为不断写缓存的情况而使得","categories":[],"tags":[]},{"title":"java","slug":"深入jvm2","date":"2019-06-04T16:20:42.000Z","updated":"2019-07-23T14:03:49.561Z","comments":true,"path":"2019/06/05/深入jvm2/","link":"","permalink":"http://yoursite.com/2019/06/05/深入jvm2/","excerpt":"","text":"jvm中的类加载java中有两大类型：基础类型和引用类型（其中基础类型是上篇中的八大基础类型）本文主要讲引用类型（类，接口，数组类，泛型参数），而泛型参数最终在编译过程中会被擦除，所以实际上是前三，而数组类是在java虚拟机生成的，正常有专门字节码的是类和接口。java变异成class文件之后，从class必须加载到内存中才能被jvm程序执行，其中经过三大步骤 加载 -&gt; 链接 -&gt; 初始化 。下面围绕着三大步骤展开加载加载，其实就jvm加载字节流的过程。java虚拟机借用类加载器加载字节流的过程。常用类加载有：启动类加载器（native方法，没有对应的java类，故采用null表示），启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类，以及由虚拟机参数 -Xbootclasspath 指定的类。其他类加载器继承自java.lang.ClassLoader，均由java核心类提供。如：扩展类加载器（extension class loader，）扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。应用类加载器（application class loader ）应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。同一个字节流经经过不同的类加载加载后是两个不同的类，这一特性经常用在运行同一个类的不同版本；双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。这个是java加载类的模式链接链接指创建完的类合并至java虚拟机中，使之能够执行的过程，他可以分为验证（验证类符合java类越苏），准备（静态字段分配内存，初始化静态字段），解析(正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载)初始化所有的静态字段，方法，代码块，以及final修饰的修饰的直接赋值都会置于一个方法中&lt; clinit &gt; ，Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt;以下是java类初始化的一些规则当虚拟机启动时，初始化用户指定的主类；当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；当遇到调用静态方法的指令时，初始化该静态方法所在的类；当遇到访问静态字段的指令时，初始化该静态字段所在的类；子类的初始化会触发父类的初始化；如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；使用反射 API 对某个类进行反射调用时，初始化这个类；当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。可以通过 JVM 参数 -verbose:class 来打印类加载的先后顺序，初始化先后，-XX：+TraceClassLoading打印类的加载过程","categories":[],"tags":[]},{"title":"jvm 理解1","slug":"深入jvm1","date":"2019-06-03T16:27:54.000Z","updated":"2021-03-08T09:46:09.348Z","comments":true,"path":"2019/06/04/深入jvm1/","link":"","permalink":"http://yoursite.com/2019/06/04/深入jvm1/","excerpt":"","text":"深入理解java虚拟机java中内存的使用情况Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。java中有八种基本类型booleanshortbyteintlongfloatdoubleString其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。boolean、byte、chat、short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。上述的操作实验可以引用sum.misc.Unsafe 下的对内存进行操作，里面部分native方法均能起到掩码操作比如：int 设置到boolean 时的掩码操作","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java网络","slug":"java网络","permalink":"http://yoursite.com/tags/java网络/"}]}